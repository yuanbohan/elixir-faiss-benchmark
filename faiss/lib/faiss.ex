defmodule Faiss do
  @moduledoc """
  help to load data to memory, cluster all the data, search k nearest neighbors
  """

  @distance_threshold 5

  @type group_id :: non_neg_integer()
  @type distance :: non_neg_integer()
  @type video_id :: binary()
  @type cluster :: %{optional(group_id()) => {video_id, [video_id()]}}

  @doc """
  convert comma seperated uint8 list to binary

  ## Examples

      iex> Faiss.line_to_binary("1,2,3")
      <<1, 2, 3>>

  """
  @spec line_to_binary(String.t()) :: video_id()
  def line_to_binary(line) do
    l = line |> String.split(",") |> Enum.map(&String.to_integer/1)
    for x <- l, into: <<>>, do: <<x>>
  end

  @doc """
  load dataset from disk and convert line to binary.

  NOTE: dataset is generated by python script usind `NumPy` lib
  """
  @spec load_one_dataset(String.t()) :: [video_id()]
  def load_one_dataset(path) do
    {:ok, contents} = File.read(path)
    contents |> String.split("\n", trim: true) |> Enum.map(&line_to_binary/1)
  end

  @spec load_all_dataset :: {[video_id()], [video_id()]}
  def load_all_dataset do
    xb = load_one_dataset("../xb.txt")
    IO.puts("load xb done")
    xq = load_one_dataset("../xq.txt")
    IO.puts("load xq done")
    {xb, xq}

    # xq = load_one_dataset("../xq.txt")
    # {[], xq}
  end

  @doc """
  cal hamming distance between 2 binaries

  ## Examples

      iex> Faiss.hamming_distance(<<1>>, <<7>>)
      2

  """
  @spec hamming_distance(video_id(), video_id()) :: distance()
  def hamming_distance(video_id1, video_id2) do
    # if using smaller bits, the performance greatly improved
    # <<bits1, _rest::binary>> = video_id1
    # <<bits2, _rest::binary>> = video_id2
    # bits = :crypto.exor(<<bits1>>, <<bits2>>)
    bits = :crypto.exor(video_id1, video_id2)
    for(<<bit::1 <- bits>>, do: bit) |> Enum.sum()
  end

  @doc """
  find the group id where the video id will be inserted

  ## Examples

      iex> Faiss.find_group_id(%{}, <<1>>)
      1
      iex> Faiss.find_group_id(%{1 => {<<1>>, [<<1>>]}}, <<127>>)
      2
  """
  @spec find_group_id(cluster(), video_id()) :: group_id()
  def find_group_id(cluster, video_id) do
    find_group_id(cluster, video_id, {1, :doing})
  end

  @doc """
  find the group id

  ## Examples

      iex> Faiss.find_group_id(%{}, <<1>>, {1, :doing})
      1
      iex> Faiss.find_group_id(%{1=>{<<2>>,[<<2>>]}, 2=>{<<127>>,[<<127>>]}}, <<63>>,{1, :doing})
      2
  """
  @spec find_group_id(cluster(), video_id(), {group_id(), atom()}) :: group_id()
  defp find_group_id(cluster, video_id, {group_id, :doing}) do
    val = Map.get(cluster, group_id)

    case val do
      nil ->
        find_group_id(cluster, video_id, {group_id, :done})

      {head_id, _} ->
        cond do
          hamming_distance(head_id, video_id) < @distance_threshold ->
            find_group_id(cluster, video_id, {group_id, :done})

          true ->
            find_group_id(cluster, video_id, {group_id + 1, :doing})
        end
    end
  end

  defp find_group_id(_cluster, _video_id, {group_id, :done}), do: group_id

  @doc """
  `cluster` store the group id, `map` store the clustered id

  ## Examples

      iex> Faiss.add(%{}, <<1>>)
      %{1 => {<<1>>, [<<1>>]}}

      iex> Faiss.add(%{1 => {<<1>>, [<<1>>]}}, <<1>>)
      %{1 => {<<1>>, [<<1>>]}}

      iex(11)> Faiss.add(%{1 => {<<1>>, [<<1>>]}}, <<127>>)
      %{1 => {<<1>>, [<<1>>]}, 2 => {"\d", ["\d"]}}

  """
  @spec add(cluster(), video_id()) :: cluster()
  def add(cluster, video_id) do
    group_id = find_group_id(cluster, video_id)

    # if rem(group_id, 100) == 0 do
    #   IO.puts("indexind: add #{group_id}")
    # end

    case Map.get(cluster, group_id) do
      nil ->
        Map.put(cluster, group_id, {video_id, [video_id]})

      {head_id, video_ids} ->
        Map.put(cluster, group_id, {head_id, Enum.uniq([video_id | video_ids])})
    end
  end

  @doc """
  cluster the dataset based on hammind distance

  ## Examples

      iex> Faiss.index([<<1>>, <<127>>, <<63>>, <<31>>, <<15>>, <<7>>, <<3>>])
      %{1 => {<<1>>, [<<3>>, <<7>>, <<15>>, <<31>>, <<1>>]}, 2 => {<<127>>, [<<63>>, <<127>>]}}

  """
  @spec index([video_id()]) :: cluster()
  def index(dataset) do
    Enum.reduce(dataset, %{}, fn video_id, acc -> add(acc, video_id) end)
  end

  @doc """
  search the group id where the minist hamming distance located

  """
  defp search_group_id(cluster, video_id, {group_id, :doing, result_id, result_dis}) do
    case Map.get(cluster, group_id) do
      nil ->
        search_group_id(cluster, video_id, {group_id, :done, result_id, result_dis})

      {head_id, _} ->
        cur_dis = hamming_distance(head_id, video_id)

        cond do
          cur_dis < @distance_threshold ->
            search_group_id(cluster, video_id, {group_id, :done, group_id, cur_dis})

          cur_dis < result_dis ->
            search_group_id(cluster, video_id, {group_id + 1, :doing, group_id, cur_dis})

          true ->
            search_group_id(cluster, video_id, {group_id + 1, :doing, result_id, result_dis})
        end
    end
  end

  defp search_group_id(_cluster, _video_id, {_, :done, result_id, _}), do: result_id

  @doc """
  find the video_id which has shortest hamming distance with the `video_id`

  Assume: the `cluster` is not empty, which means `cluster` contains `1` key

  """
  @spec search(cluster(), video_id()) :: video_id()
  def search(cluster, target_id) do
    group_id = search_group_id(cluster, target_id, {1, :doing, 1, :inf})
    {_, group_video_ids} = Map.get(cluster, group_id, [])
    Enum.min_by(group_video_ids, fn video_id -> hamming_distance(video_id, target_id) end)
  end
end
